---
title: "Making a Todo Example for My Framework"
summary: ""
---
This year I started working on a framework that I published as [@erickmerchant/framework](https://www.npmjs.com/package/@erickmerchant/framework) to npm. It's not meant to be a serious contender in the world of frameworks. By which I mean I'm not going to advocate that others use it, and if I ever do I'll give it a less generic name and publish it as an unscoped package. But I intend to use it for any of my many ideas. It's inspired by React and others, but without JSX and much simpler. I first saw the term "data down, actions up" with yo-yo and I'd describe it as such. It doesn't come with a built-in way of outputting html, but I've been using it with diffhtml, and originally with yo-yo. I need to work again on testing use of yo-yo. This month I've been working a lot on making a Todo example for it, as in TodoMVC. Below is the javascript for that with a lot of comments. The syntax highlighting a bit wrong below, but I switched from highlight.js to prismjs for this post and it's better than it was. The source live version of this.

``` javascript
/* we'll need the framework, ift (to make conditionals more readable), and diffhtml */
const framework = require('@erickmerchant/framework')
const ift = require('@erickmerchant/ift')('')
const diff = require('diffhtml')
const html = diff.html
/* we need a dom element, a place where the application will be rendered */
const target = document.querySelector('main')
/* a global setting used by the store, a key for localStorage */
const storageKey = 'todo-data'

/* here we start the application, passing in the target (seen above), the store and component (both seen below), and diff.innerHTML as diff which will be used to update the target with the results from calling component */
framework({target, store, component, diff: diff.innerHTML})(function ({dispatch}) {
  /* calling framework returns a function to do some initial dispatch calls or set up global event handlers that will need dispatch. In this case we set up a very minimal hash router */
  window.onhashchange = function () {
    dispatch('set-current-filter', {filter: window.location.hash})
  }

  dispatch('set-current-filter', {filter: window.location.hash})
})

/* the store is the source of truth for the state of our application. Every time dispatch is called the store is called with the previous state (previously returned from calling the store) and any arguments passed to dispatch. It returns a new state. Though an immutable state is not used in this example, using something like immutable.js can be a good idea. Here we just practice disciple and only modify the state inside the store. At the top of this store we set up a default state as a default parameter
  - todos: this will be our items. a Map
  - current: if we're editing an item, this is it
  - next: a number, incremented on every item and used as the key for our item
  - currentFilter: should correspond to the current window.location.hash or '#/all' by default
*/
function store (state = {todos: null, current: false, next: 0, currentFilter: '#/all'}, action, args) {
  if (state.todos == null) {
    /* if state.todos is null (first call to store) we'll check to see if there is something in localStorage use the key defined above */
    let stored = window.localStorage.getItem(storageKey)
    let data = {}

    if (stored) {
      try {
        data = JSON.parse(stored)
      } catch (e) {
        console.error(e)
      }
    }

    /* the todos and next should both be defined */
    state.todos = new Map(data.todos || [])
    state.next = data.next || 0
  }

  if (action === 'set-current') {
    state.current = args.id
  }

  if (action === 'set-current-filter') {
    state.currentFilter = args.filter
  }

  if (action === 'unset-current') {
    state.current = false
  }

  if (action === 'add-todo') {
    state.todos.set(state.next++, {
      title: args.title,
      completed: false
    })
  }

  if (action === 'edit-todo') {
    if (state.todos.has(args.id)) {
      let todo = state.todos.get(args.id)

      todo.title = args.title
    }
  }

  if (action === 'toggle-all-completed') {
    state.todos.forEach((todo) => {
      todo.completed = args.completed
    })
  }

  if (action === 'toggle-completed') {
    if (state.todos.has(args.id)) {
      let todo = state.todos.get(args.id)

      todo.completed = !todo.completed
    }
  }

  if (action === 'remove-todo') {
    if (state.todos.has(args.id)) {
      state.todos.delete(args.id)
    }
  }

  if (action === 'remove-completed') {
    state.todos.forEach((todo, id) => {
      if (todo.completed) {
        state.todos.delete(id)
      }
    })
  }

  window.localStorage.setItem(storageKey, JSON.stringify({todos: [...state.todos], next: state.next}))

  return state
}

function component ({state, dispatch, next}) {
  const allTodos = [...state.todos]
  const totalCount = allTodos.length
  const completedCount = allTodos.reduce((count, [id, todo]) => todo.completed ? count + 1 : count, 0)
  const activeCount = totalCount - completedCount

  const allTodosCompleted = activeCount === 0
  const someTodosCompleted = completedCount > 0

  next(function ({target}) {
    const input = target.querySelector('input.edit')

    if (input) {
      input.focus()

      input.value = input.value
    }
  })

  return html`<section class="todoapp">
    <header class="header">
      <h1>todos</h1>
      <input class="new-todo"
        autofocus autocomplete="off"
        placeholder="What needs to be done?"
        onkeyup="${addTodo}">
    </header>
    ${ift(totalCount > 0, () => {
      return html`<section class="main">
        <input class="toggle-all" type="checkbox" onclick="${toggleAllCompleted(allTodosCompleted)}" ${ift(allTodosCompleted, 'checked')}>
        <ul class="todo-list">
          ${allTodos.filter(([id, todo]) => {
            if (state.currentFilter === '#/active') return !todo.completed

            if (state.currentFilter === '#/completed') return todo.completed

            return true
          }).map(([id, todo]) => {
            return html`<li class="todo ${ift(todo.completed, 'completed')} ${ift(state.current === id, 'editing')}">
              <div class="view">
                <input class="toggle" type="checkbox" onclick="${toggleCompleted(id)}" ${ift(todo.completed, 'checked')}>
                <label ondblclick="${setCurrent(id)}">${todo.title}</label>
                <button class="destroy" onclick="${removeTodo(id)}"></button>
              </div>
              ${ift(state.current === id, () => html`<input class="edit" type="text" value="${todo.title}" onkeyup="${exitCurrent(id)}">`)}
            </li>`
          })}
        </ul>
      </section>`
    })}
    ${ift(totalCount > 0, () => {
      return html`<footer class="footer">
        <span class="todo-count">
          <strong>${activeCount}</strong> ${ift(activeCount !== 1, 'items', 'item')} left
        </span>
        <ul class="filters">
          <li><a href="#/all" class="${ift(state.currentFilter === '#/all', 'selected')}">All</a></li>
          <li><a href="#/active" class="${ift(state.currentFilter === '#/active', 'selected')}">Active</a></li>
          <li><a href="#/completed" class="${ift(state.currentFilter === '#/completed', 'selected')}">Completed</a></li>
        </ul>
        ${ift(someTodosCompleted, () => {
          return html`<button class="clear-completed" onclick="${removeCompleted}">
            Clear completed
          </button>`
        })}
      </footer>`
    })}
  </section>
  <footer class="info">
    <p>Double-click to edit a todo</p>
    <p>Created by <a href="http://erickmerchant.com">Erick Merchant</a></p>
    <p>Part of <a href="http://todomvc.com">TodoMVC</a></p>
    <p>View the source <a href="https://github.com/erickmerchant/framework-todo">here</a></p>
  </footer>`

  function addTodo (e) {
    if (e.keyCode === 13 && this.value) {
      let title = this.value

      dispatch('add-todo', {title})

      this.value = ''
    }
  }

  function exitCurrent (id) {
    return function (e) {
      if (e.keyCode === 13) {
        dispatch('unset-current')

        if (this.value) {
          let title = this.value

          dispatch('edit-todo', {id, title})
        } else {
          dispatch('remove-todo', {id})
        }
      }

      if (e.keyCode === 27) {
        dispatch('unset-current')
      }
    }
  }

  function setCurrent (id) {
    return function () {
      dispatch('set-current', {id})
    }
  }

  function toggleAllCompleted (checked) {
    return function (e) {
      let completed = !checked
      dispatch('toggle-all-completed', {completed})
    }
  }

  function toggleCompleted (id) {
    return function (e) {
      e.preventDefault()

      dispatch('toggle-completed', {id})
    }
  }

  function removeTodo (id) {
    return function () {
      dispatch('remove-todo', {id})
    }
  }

  function removeCompleted () {
    dispatch('remove-completed')
  }
}
```
